<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time TON Transaction Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4facfe;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .transactions-section {
            padding: 30px;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .transaction-list {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 15px;
            background: white;
        }

        .transaction-item {
            padding: 20px;
            border-bottom: 1px solid #f1f3f4;
            transition: background-color 0.3s ease;
            animation: slideIn 0.5s ease-out;
        }

        .transaction-item:hover {
            background-color: #f8f9fa;
        }

        .transaction-item:last-child {
            border-bottom: none;
        }

        .transaction-item.new {
            background: linear-gradient(90deg, #d4edda, #ffffff);
            border-left: 4px solid #28a745;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .transaction-amount {
            font-size: 1.2em;
            font-weight: bold;
            color: #28a745;
        }

        .transaction-time {
            color: #6c757d;
            font-size: 0.9em;
        }

        .transaction-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9em;
        }

        .transaction-hash {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 5px;
            word-break: break-all;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            color: #4facfe;
            word-break: break-all;
        }

        .no-transactions {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .no-transactions i {
            font-size: 3em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 30px;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 30px;
            border: 1px solid #c3e6cb;
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .transaction-details {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Real-Time TON Transaction Monitor</h1>
            <p>Live monitoring of blockchain transactions</p>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting...</span>
            </div>
            <div>
                <span id="lastUpdate">Never</span>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="totalTransactions">0</div>
                <div class="stat-label">Total Transactions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalAmount">0.00</div>
                <div class="stat-label">Total Amount (TON)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="recentTransactions">0</div>
                <div class="stat-label">Recent (Last Hour)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="userBalance">0.00</div>
                <div class="stat-label">User Balance (TON)</div>
            </div>
        </div>

        <div class="transactions-section">
            <div class="section-title">
                üìä Live Transactions
                <div class="loading" id="loadingSpinner" style="display: none;"></div>
            </div>
            <div class="transaction-list" id="transactionList">
                <div class="no-transactions">
                    <div style="font-size: 3em; margin-bottom: 20px;">‚è≥</div>
                    <h3>Waiting for transactions...</h3>
                    <p>New transactions will appear here in real-time</p>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="toggleMonitoring()" id="toggleBtn">Start Monitoring</button>
            <button class="btn btn-secondary" onclick="clearTransactions()">Clear List</button>
            <button class="btn btn-secondary" onclick="refreshData()">Refresh</button>
        </div>
    </div>

    <script>
        class TransactionMonitor {
            constructor() {
                this.apiBaseUrl = 'http://localhost:5001';
                this.isMonitoring = false;
                this.transactions = [];
                this.pollInterval = null;
                this.lastTransactionHash = null;
                this.stats = {
                    totalTransactions: 0,
                    totalAmount: 0,
                    recentTransactions: 0,
                    userBalance: 0
                };
                
                this.init();
            }

            init() {
                this.updateStatus('Initializing...', false);
                this.checkServerConnection();
                this.loadInitialData();
            }

            async checkServerConnection() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/api/status`);
                    if (response.ok) {
                        this.updateStatus('Connected', true);
                        return true;
                    }
                } catch (error) {
                    console.error('Server connection failed:', error);
                }
                this.updateStatus('Server Offline', false);
                return false;
            }

            async loadInitialData() {
                try {
                    await this.loadTransactions();
                    await this.loadStats();
                    await this.loadUserBalance();
                } catch (error) {
                    console.error('Failed to load initial data:', error);
                    this.showError('Failed to load initial data');
                }
            }

            async loadTransactions() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/api/transactions/recent?limit=20`);
                    if (response.ok) {
                        const data = await response.json();
                        this.transactions = data.transactions || [];
                        this.renderTransactions();
                    }
                } catch (error) {
                    console.error('Failed to load transactions:', error);
                }
            }

            async loadStats() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/api/stats`);
                    if (response.ok) {
                        const data = await response.json();
                        this.stats.totalTransactions = data.total_transactions || 0;
                        this.stats.totalAmount = data.total_amount || 0;
                        this.updateStatsDisplay();
                    }
                } catch (error) {
                    console.error('Failed to load stats:', error);
                }
            }

            async loadUserBalance() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/api/user-balance/0000000`);
                    if (response.ok) {
                        const data = await response.json();
                        this.stats.userBalance = data.balance || 0;
                        this.updateStatsDisplay();
                    }
                } catch (error) {
                    console.error('Failed to load user balance:', error);
                }
            }

            async pollForNewTransactions() {
                if (!this.isMonitoring) return;

                try {
                    const response = await fetch(`${this.apiBaseUrl}/api/realtime/latest?limit=5`);
                    if (response.ok) {
                        const data = await response.json();
                        const newTransactions = data.deposits || [];
                        
                        // Check for new transactions
                        for (const tx of newTransactions) {
                            if (!this.lastTransactionHash || tx.hash !== this.lastTransactionHash) {
                                this.addNewTransaction(tx);
                                this.lastTransactionHash = tx.hash;
                            }
                        }
                        
                        this.updateLastUpdateTime();
                        this.updateStatus('Monitoring Active', true);
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                    this.updateStatus('Connection Error', false);
                }
            }

            addNewTransaction(tx) {
                // Convert API format to display format
                const transaction = {
                    tx_hash: tx.hash,
                    sender_address: tx.wallet_address,
                    amount_ton: tx.amount,
                    timestamp: new Date(tx.detected_at).getTime() / 1000,
                    created_at: tx.detected_at
                };

                // Add to beginning of list
                this.transactions.unshift(transaction);
                
                // Keep only last 50 transactions
                if (this.transactions.length > 50) {
                    this.transactions = this.transactions.slice(0, 50);
                }

                // Update stats
                this.stats.totalTransactions++;
                this.stats.totalAmount += parseFloat(tx.amount);
                this.stats.userBalance += parseFloat(tx.amount);

                this.renderTransactions(true);
                this.updateStatsDisplay();
                this.showSuccess(`New transaction: ${tx.amount} TON received!`);
                
                // Play notification sound (if supported)
                this.playNotificationSound();
            }

            renderTransactions(highlightNew = false) {
                const container = document.getElementById('transactionList');
                
                if (this.transactions.length === 0) {
                    container.innerHTML = `
                        <div class="no-transactions">
                            <div style="font-size: 3em; margin-bottom: 20px;">‚è≥</div>
                            <h3>Waiting for transactions...</h3>
                            <p>New transactions will appear here in real-time</p>
                        </div>
                    `;
                    return;
                }

                const html = this.transactions.map((tx, index) => {
                    const isNew = highlightNew && index === 0;
                    const date = new Date(tx.created_at || tx.timestamp * 1000);
                    const timeAgo = this.getTimeAgo(date);
                    
                    return `
                        <div class="transaction-item ${isNew ? 'new' : ''}">
                            <div class="transaction-header">
                                <div class="transaction-amount">+${parseFloat(tx.amount_ton).toFixed(4)} TON</div>
                                <div class="transaction-time">${timeAgo}</div>
                            </div>
                            <div class="transaction-details">
                                <div>
                                    <strong>From:</strong><br>
                                    <span class="wallet-address">${this.truncateAddress(tx.sender_address)}</span>
                                </div>
                                <div>
                                    <strong>Hash:</strong><br>
                                    <span class="transaction-hash">${this.truncateHash(tx.tx_hash)}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = html;
            }

            updateStatsDisplay() {
                document.getElementById('totalTransactions').textContent = this.stats.totalTransactions;
                document.getElementById('totalAmount').textContent = this.stats.totalAmount.toFixed(4);
                document.getElementById('recentTransactions').textContent = this.getRecentTransactionsCount();
                document.getElementById('userBalance').textContent = this.stats.userBalance.toFixed(4);
            }

            getRecentTransactionsCount() {
                const oneHourAgo = Date.now() - (60 * 60 * 1000);
                return this.transactions.filter(tx => {
                    const txTime = new Date(tx.created_at || tx.timestamp * 1000).getTime();
                    return txTime > oneHourAgo;
                }).length;
            }

            startMonitoring() {
                if (this.isMonitoring) return;
                
                this.isMonitoring = true;
                this.pollInterval = setInterval(() => {
                    this.pollForNewTransactions();
                }, 3000); // Poll every 3 seconds
                
                document.getElementById('toggleBtn').textContent = 'Stop Monitoring';
                document.getElementById('loadingSpinner').style.display = 'inline-block';
                this.updateStatus('Starting Monitor...', true);
                
                // Start monitoring on server
                fetch(`${this.apiBaseUrl}/api/realtime/start`, { method: 'POST' })
                    .catch(error => console.error('Failed to start server monitoring:', error));
            }

            stopMonitoring() {
                if (!this.isMonitoring) return;
                
                this.isMonitoring = false;
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
                
                document.getElementById('toggleBtn').textContent = 'Start Monitoring';
                document.getElementById('loadingSpinner').style.display = 'none';
                this.updateStatus('Monitoring Stopped', false);
                
                // Stop monitoring on server
                fetch(`${this.apiBaseUrl}/api/realtime/stop`, { method: 'POST' })
                    .catch(error => console.error('Failed to stop server monitoring:', error));
            }

            updateStatus(text, connected) {
                document.getElementById('statusText').textContent = text;
                const dot = document.getElementById('statusDot');
                if (connected) {
                    dot.classList.add('connected');
                } else {
                    dot.classList.remove('connected');
                }
            }

            updateLastUpdateTime() {
                const now = new Date();
                document.getElementById('lastUpdate').textContent = now.toLocaleTimeString();
            }

            clearTransactions() {
                this.transactions = [];
                this.renderTransactions();
                this.showSuccess('Transaction list cleared');
            }

            async refreshData() {
                document.getElementById('loadingSpinner').style.display = 'inline-block';
                await this.loadInitialData();
                document.getElementById('loadingSpinner').style.display = 'none';
                this.showSuccess('Data refreshed');
            }

            truncateAddress(address) {
                if (!address) return 'Unknown';
                return `${address.substring(0, 8)}...${address.substring(address.length - 8)}`;
            }

            truncateHash(hash) {
                if (!hash) return 'Unknown';
                return `${hash.substring(0, 12)}...${hash.substring(hash.length - 12)}`;
            }

            getTimeAgo(date) {
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);
                const diffDays = Math.floor(diffHours / 24);

                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                return `${diffDays}d ago`;
            }

            showError(message) {
                this.showMessage(message, 'error');
            }

            showSuccess(message) {
                this.showMessage(message, 'success');
            }

            showMessage(message, type) {
                // Remove existing messages
                const existing = document.querySelector('.error-message, .success-message');
                if (existing) existing.remove();

                const div = document.createElement('div');
                div.className = type === 'error' ? 'error-message' : 'success-message';
                div.textContent = message;
                
                const container = document.querySelector('.container');
                container.appendChild(div);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (div.parentNode) div.remove();
                }, 5000);
            }

            playNotificationSound() {
                try {
                    // Create a simple beep sound
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('Audio notification not supported');
                }
            }
        }

        // Global functions for buttons
        let monitor;

        function toggleMonitoring() {
            if (monitor.isMonitoring) {
                monitor.stopMonitoring();
            } else {
                monitor.startMonitoring();
            }
        }

        function clearTransactions() {
            monitor.clearTransactions();
        }

        function refreshData() {
            monitor.refreshData();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            monitor = new TransactionMonitor();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, reduce polling frequency
                if (monitor && monitor.isMonitoring && monitor.pollInterval) {
                    clearInterval(monitor.pollInterval);
                    monitor.pollInterval = setInterval(() => {
                        monitor.pollForNewTransactions();
                    }, 10000); // Poll every 10 seconds when hidden
                }
            } else {
                // Page is visible, restore normal polling
                if (monitor && monitor.isMonitoring && monitor.pollInterval) {
                    clearInterval(monitor.pollInterval);
                    monitor.pollInterval = setInterval(() => {
                        monitor.pollForNewTransactions();
                    }, 3000); // Poll every 3 seconds when visible
                }
            }
        });
    </script>
</body>
</html>
